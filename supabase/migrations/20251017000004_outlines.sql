-- AI-Powered Outline System
-- Stores outlines generated by Claude 4.5 with support for multiple formats

-- Create outlines table
CREATE TABLE IF NOT EXISTS public.outlines (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    project_id UUID NOT NULL REFERENCES public.projects(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    format TEXT NOT NULL CHECK (format IN ('chapter_summary', 'scene_by_scene', 'treatment', 'beat_outline', 'custom')),
    premise TEXT,
    content JSONB NOT NULL DEFAULT '[]'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create outline_sections table for hierarchical structure
CREATE TABLE IF NOT EXISTS public.outline_sections (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    outline_id UUID NOT NULL REFERENCES public.outlines(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    parent_id UUID REFERENCES public.outline_sections(id) ON DELETE CASCADE,
    order_position INTEGER NOT NULL DEFAULT 0,
    title TEXT NOT NULL,
    description TEXT,
    notes TEXT,
    word_count_target INTEGER,
    page_count_target INTEGER,
    is_completed BOOLEAN DEFAULT false,
    metadata JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE public.outlines ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.outline_sections ENABLE ROW LEVEL SECURITY;

-- RLS Policies for outlines
CREATE POLICY "Users can view their own outlines"
    ON public.outlines FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own outlines"
    ON public.outlines FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own outlines"
    ON public.outlines FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own outlines"
    ON public.outlines FOR DELETE
    USING (auth.uid() = user_id);

-- RLS Policies for outline_sections
CREATE POLICY "Users can view their own outline sections"
    ON public.outline_sections FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own outline sections"
    ON public.outline_sections FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own outline sections"
    ON public.outline_sections FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own outline sections"
    ON public.outline_sections FOR DELETE
    USING (auth.uid() = user_id);

-- Indexes for performance
CREATE INDEX idx_outlines_user_id ON public.outlines(user_id);
CREATE INDEX idx_outlines_project_id ON public.outlines(project_id);
CREATE INDEX idx_outlines_created_at ON public.outlines(created_at DESC);
CREATE INDEX idx_outline_sections_outline_id ON public.outline_sections(outline_id);
CREATE INDEX idx_outline_sections_parent_id ON public.outline_sections(parent_id);
CREATE INDEX idx_outline_sections_order ON public.outline_sections(order_position);

-- Trigger to update updated_at on outlines
CREATE OR REPLACE FUNCTION update_outlines_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_outlines_timestamp
    BEFORE UPDATE ON public.outlines
    FOR EACH ROW
    EXECUTE FUNCTION update_outlines_updated_at();

-- Trigger to update updated_at on outline_sections
CREATE OR REPLACE FUNCTION update_outline_sections_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_outline_sections_timestamp
    BEFORE UPDATE ON public.outline_sections
    FOR EACH ROW
    EXECUTE FUNCTION update_outline_sections_updated_at();

-- Function to generate outline using AI
CREATE OR REPLACE FUNCTION generate_ai_outline(
    p_project_id UUID,
    p_user_id UUID,
    p_premise TEXT,
    p_format TEXT,
    p_additional_context TEXT DEFAULT NULL
)
RETURNS TABLE (
    id UUID,
    title TEXT,
    format TEXT,
    content JSONB,
    metadata JSONB
) AS $$
DECLARE
    v_project_record RECORD;
    v_outline_id UUID;
    v_title TEXT;
BEGIN
    -- Get project details
    SELECT * INTO v_project_record
    FROM public.projects
    WHERE projects.id = p_project_id AND projects.user_id = p_user_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Project not found';
    END IF;

    -- Generate title based on format
    v_title := CASE p_format
        WHEN 'chapter_summary' THEN 'Chapter Summary Outline'
        WHEN 'scene_by_scene' THEN 'Scene-by-Scene Outline'
        WHEN 'treatment' THEN 'Treatment'
        WHEN 'beat_outline' THEN 'Beat-Based Outline'
        ELSE 'Custom Outline'
    END;

    -- Create outline record (AI generation happens in API layer)
    INSERT INTO public.outlines (user_id, project_id, title, format, premise, content, metadata)
    VALUES (
        p_user_id,
        p_project_id,
        v_title,
        p_format,
        p_premise,
        '[]'::jsonb,
        jsonb_build_object(
            'project_type', v_project_record.type,
            'project_genre', v_project_record.genre,
            'additional_context', p_additional_context
        )
    )
    RETURNING outlines.id INTO v_outline_id;

    -- Return the created outline
    RETURN QUERY
    SELECT
        outlines.id,
        outlines.title,
        outlines.format,
        outlines.content,
        outlines.metadata
    FROM public.outlines
    WHERE outlines.id = v_outline_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Seed sample outline formats (metadata only)
INSERT INTO public.outlines (user_id, project_id, title, format, premise, content, metadata)
SELECT
    auth.uid(),
    (SELECT id FROM public.projects WHERE user_id = auth.uid() LIMIT 1),
    'Getting Started Guide',
    'custom',
    'This is a sample outline to help you understand the outline system.',
    jsonb_build_array(
        jsonb_build_object(
            'type', 'section',
            'title', 'Act I: Setup',
            'description', 'Introduce characters, world, and central conflict'
        ),
        jsonb_build_object(
            'type', 'section',
            'title', 'Act II: Confrontation',
            'description', 'Rising action, complications, character development'
        ),
        jsonb_build_object(
            'type', 'section',
            'title', 'Act III: Resolution',
            'description', 'Climax and resolution of conflicts'
        )
    ),
    jsonb_build_object('is_sample', true)
WHERE EXISTS (SELECT 1 FROM auth.users WHERE id = auth.uid())
ON CONFLICT DO NOTHING;
